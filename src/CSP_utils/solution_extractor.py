import os
import io
import re

# Extracts solutions from the log files generated by Minizinc and then saves the wxh out.txt files and returns dictionaries for the successful, unsatisfiable and unknown instances.
def save_solutions(working_dir, models, log_dir, output_dir):
    successful = {}
    unsatisfiable = {}
    unknown = {}

    model_dir = [m.replace(".mzn", "") for m in models]
    for i in range(len(model_dir)):
        successful[model_dir[i]] = []
        unsatisfiable[model_dir[i]] = []
        unknown[model_dir[i]] = []
        path = "{}/{}/{}".format(working_dir, log_dir, model_dir[i])
        for file in os.listdir(path):
            with io.open(path + "/" + file) as f:
                content = f.read()
            if re.search("UNKNOWN", content):
                unknown[model_dir[i]].append(file.replace(".log", ""))
            elif re.search("UNSATISFIABLE", content):
                unsatisfiable[model_dir[i]].append(file.replace(".log", ""))
            else:
                wh = [int(x) for x in file.replace(".log", "").split("x")]
                area = wh[0] * wh[1]
                match = re.search("solveTime=([0-9]*\.?[0-9]*)\n", content)
                if match:
                    time = float(match.group(1))
                else:
                    time = 0
                match = re.search("failures=([0-9]+)\n", content)
                if match:
                    failures = int(match.group(1))
                else:
                    failures = 0
                match = re.search("restarts=([0-9]+)\n", content)
                if match:
                    restarts = int(match.group(1))
                else:
                    restarts = 0

                match = re.search("x = \[(.*)\]\n", content)
                if match:
                    x_string = match.group(1)
                else:
                    x_string = ""
                match = re.search("y = \[(.*)\]\n", content)
                if match:
                    y_string = match.group(1)
                else:
                    y_string = ""
                match = re.search("w = \[(.*)\]\n", content)
                if match:
                    w_string = match.group(1)
                else:
                    w_string = ""
                match = re.search("h = \[(.*)\]\n", content)
                if match:
                    h_string = match.group(1)
                else:
                    h_string = ""

                x = [int(i) for i in x_string.split(", ") if i != ""]
                y = [int(i) for i in y_string.split(", ") if i != ""]
                w = [int(i) for i in w_string.split(", ") if i != ""]
                h = [int(i) for i in h_string.split(", ") if i != ""]
                n_rects = len(x)

                if n_rects > 0:
                    successful[model_dir[i]].append({"name": file.replace(".log", ""), "area": area, "rectangles": n_rects, "time": time, "failures": failures, "restarts": restarts, "x": x, "y": y, "w": w, "h": h})
        for s in successful[model_dir[i]]:
            if not os.path.exists(r"{}/{}/{}".format(working_dir, output_dir, model_dir[i])):
                os.makedirs(r"{}/{}/{}".format(working_dir, output_dir, model_dir[i]))

            out = "{}/{}/{}/{}".format(working_dir, output_dir, model_dir[i], s["name"] + " out.txt")
            wh = s["name"].split("x")
            with io.open(out, "w+") as output_file:
                output_file.write("{} {}\n".format(wh[0], wh[1]))
                output_file.write("{}\n".format(s["rectangles"]))
                for j in range(len(s["x"])):
                    output_file.write("{} {} {} {}\n".format(s["x"][j], s["y"][j], s["w"][j], s["h"][j]))

    return successful, unsatisfiable, unknown